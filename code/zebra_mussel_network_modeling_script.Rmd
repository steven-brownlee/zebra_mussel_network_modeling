# Zebra mussel network modeling script

# Contact information

Contact: Steven Brownlee
Email: steven.fr.brownlee@gmail.com
Date last revised: June 24 2024

# Session info

R version 4.4.1 (2024-06-14)
Platform: x86_64-redhat-linux-gnu
Running under: Nobara Linux 40 (GNOME Edition)

Matrix products: default
BLAS/LAPACK: FlexiBLAS OPENBLAS-OPENMP;  LAPACK version 3.11.0

locale:
 [1] LC_CTYPE=en_CA.UTF-8      LC_NUMERIC=C              LC_TIME=en_CA.utf8       
 [4] LC_COLLATE=en_CA.UTF-8    LC_MONETARY=en_CA.utf8    LC_MESSAGES=en_CA.UTF-8  
 [7] LC_PAPER=en_CA.utf8       LC_NAME=C                 LC_ADDRESS=C             
[10] LC_TELEPHONE=C            LC_MEASUREMENT=en_CA.utf8 LC_IDENTIFICATION=C      

time zone: America/Vancouver
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
 [1] digest_0.6.36     tidyr_1.3.1       utf8_1.2.4        R6_2.5.1         
 [5] fastmap_1.2.0     tidyselect_1.2.1  xfun_0.46         magrittr_2.0.3   
 [9] glue_1.7.0        tibble_3.2.1      knitr_1.48        pkgconfig_2.0.3  
[13] htmltools_0.5.8.1 rmarkdown_2.27    dplyr_1.1.4       generics_0.1.3   
[17] lifecycle_1.0.4   cli_3.6.3         fansi_1.0.6       vctrs_0.6.5      
[21] compiler_4.4.1    purrr_1.0.2       rstudioapi_0.16.0 tools_4.4.1      
[25] pillar_1.9.0      evaluate_0.24.0   yaml_2.3.10       rlang_1.1.4   

# Set up data directory

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = '/home/steven/Documents/workspace/thesis/ch2/gis_data/')
```

# R library setup

```{r}
library(sf)
library(tidyverse)
library(rcartocolor)
library(sfnetworks)
library(qgisprocess)
library(future)
library(future.callr)
library(purrr)
library(furrr)
library(progressr)

```

# Import shapefiles

```{r}
zm_occurrences <- read_sf('processed/dreissenid_occurrences.gpkg') %>% 
  st_transform(crs = 'ESRI:102008')

us_metro <- read_sf('processed/us_metro_areas.gpkg')%>% 
  st_transform(crs = 'ESRI:102008')

canada_metro <- read_sf('processed/canada_metro_areas.gpkg')%>% 
  st_transform(crs = 'ESRI:102008')

land <- read_sf('processed/shared_north_america_coastline.gpkg') %>% 
  st_transform(crs = 'ESRI:102008')

lakes <- read_sf('processed/cec_lakes.gpkg') %>% 
  st_transform(crs = 'ESRI:102008')

usdot_road_network <- read_sf('processed/usdot_road_network.gpkg')%>% 
  st_transform(crs = 'ESRI:102008')

qgis_bbox <- read_sf('processed/qgis_bbox.gpkg') %>% 
  st_transform(crs = 'ESRI:102008')

```


# Pre-processing

```{r}
# Create buffers around ZM occurrences

zm_10 <- st_buffer(zm_occurrences, dist = 10000) %>% st_union() %>% st_as_sf() %>% 
  mutate(buffer_dist = '10 km')

zm_20 <- st_buffer(zm_occurrences, dist = 20000) %>% st_union() %>% st_as_sf() %>% 
  mutate(buffer_dist = '20 km')

zm_30 <- st_buffer(zm_occurrences, dist = 30000) %>% st_union() %>% st_as_sf() %>% 
  mutate(buffer_dist = '30 km')

zm_40 <- st_buffer(zm_occurrences, dist = 40000) %>% st_union() %>% st_as_sf() %>% 
  mutate(buffer_dist = '40 km')

zm_50 <- st_buffer(zm_occurrences, dist = 50000) %>% st_union() %>% st_as_sf() %>% 
  mutate(buffer_dist = '50 km')

zm_buffer_collected <- rbind(zm_50, zm_40, zm_30, zm_20, zm_10)

rm(zm_50, zm_40, zm_30, zm_20, zm_10)

zm_buffer_collected$buffer_dist <- factor(zm_buffer_collected$buffer_dist, levels = c('50 km', '40 km', '30 km', '20 km', '10 km'))

zm_buffer_collected <- st_transform(zm_buffer_collected, crs = 4326)

write_sf(zm_buffer_collected, 'processed/zm_buffer.gpkg')

# Merge US and Canada metro areas

us_metro <- us_metro %>% select(NAME) %>% rename(metro_area = NAME)

canada_metro <- canada_metro %>% select(CMANAME) %>% rename(metro_area = CMANAME)

north_america_metro <- rbind(us_metro, canada_metro)

# Create node network for USDOT roads
```


```{r}
usdot_road_network <- usdot_road_network %>% rownames_to_column('seg_id')

usdot_road_network <- usdot_road_network %>% mutate(length_m = LENGTH*1000)

plan(callr, workers = 6)
options(future.globals.maxSize= 891289600)

node_generator <- function(sublist) {

for (x in sublist) {
  usdot_template <- tibble(x_coord = numeric(),
                         y_coord = numeric(),
                         country = character(),
                         usdot_id = numeric(),
                         jurisdiction = character(),
                         road_number = character(),
                         road_name = character(),
                         surface_type = character(),
                         lanes = numeric(),
                         speed_limit = numeric(),
                         class = numeric())
  
segment_filtered <- usdot_road_network %>% filter(seg_id == x)
#segment_length = as.numeric(st_length(segment_filtered))
segment_length = segment_filtered$length_m

if (segment_length <= 500) {
  sample_size = 10
} else if (500 < segment_length & segment_length <= 2000 ) {
  sample_size = 150
} else if (2000 < segment_length & segment_length <= 5000) {
  sample_size = 500 
} else if (5000 < segment_length & segment_length <= 10000) {
  sample_size = 1000 
} else if (10000 < segment_length & segment_length <= 50000) {
  sample_size = 5000 
} else if (10000 < segment_length & segment_length <= 50000) {
  sample_size = 7000
} else if (50000 < segment_length & segment_length <= 400000) {
  sample_size = 10000 
} else  {sample_size = 4000} 

usdot_nodes <- st_sample(segment_filtered, size = sample_size, type = 'regular') %>% 
  st_cast("POINT") %>% 
  st_as_sf() %>% 
  mutate(x_coord = sf::st_coordinates(.)[,1],
         y_coord = sf::st_coordinates(.)[,2],
         usdot_id = segment_filtered$ID,
         country = segment_filtered$COUNTRY,
         jurisdiction = segment_filtered$JURISNAME,
         road_number = segment_filtered$ROADNUM,
         road_name = segment_filtered$ROADNAME,
         surface_type = segment_filtered$SURFACE,
         lanes = segment_filtered$LANES,
         speed_limit = segment_filtered$SPEEDLIM,
         class = segment_filtered$CLASS) %>% 
  st_drop_geometry()

usdot_nodes$x_coord <- as.numeric(usdot_nodes$x_coord)
usdot_nodes$y_coord <- as.numeric(usdot_nodes$y_coord)

usdot_template <- rbind(usdot_template, usdot_nodes) 

}
usdot_filled <- usdot_template
return(usdot_filled)
}

usdot_nodes <- future_map(1:716644, ~node_generator(.x))

###

usdot_nodes_2 <- bind_rows(usdot_nodes)

write_rds(usdot_nodes_2, 'outputs/node_folder/usdot_combined_2.rds')

usdot_combined <- read_rds('outputs/node_folder/usdot_combined_2.rds') %>% 
  drop_na() %>% 
  st_as_sf( coords = c('x_coord', 'y_coord'), crs = st_crs('ESRI:102008'))

write_sf(usdot_combined, 'outputs/node_folder/usdot_sf.gpkg')

###
```


```{r}
overlay_grid <- st_make_grid(qgis_bbox, cellsize = 2000,
                             what = 'polygons', square = FALSE) %>% st_as_sf() %>% 
  st_transform(crs = 'ESRI:102008')

#write_sf(overlay_grid, 'processed/2km_hexagon_grid.gpkg')

overlay_grid <- read_sf('processed/2km_hexagon_grid.gpkg')

overlay_grid <- overlay_grid %>% rowid_to_column('hex_id')

overlay_grid$hex_group <- as.numeric(cut_number(overlay_grid$hex_id, 1000))

for (x in 1:1000) {
  overlay_subset <- overlay_grid %>% filter(hex_group == x)
  write_sf(overlay_subset, paste0('outputs/overlay_grid_segments/hex_group_', x, '.gpkg'))
  print(paste('Completed:', x))
}

###

overlay_subset_list <- list.files('outputs/overlay_grid_segments/', 
                            pattern = 'hex_group_*',
                            full.names = TRUE,
                            recursive = TRUE)

overlay_subset_path = 'outputs/overlay_grid_joined/'

counter = 1

for (x in overlay_subset_list) {
  hexagon_subset <- read_sf(x)
  hexagon_subset <- hexagon_subset %>%
  filter(st_intersects(., usdot_sf, sparse = FALSE)[1,])
  hexagon_joined <- st_join(hexagon_subset, usdot_sf) 
  write_sf(hexagon_joined, paste0(overlay_subset_path, 'overlay_joined_', 
                                  counter, '.gpkg'))
  print(paste('Completed:', x))
  counter = counter + 1 
  }
  
overlay_joined_list <- list.files('outputs/overlay_grid_joined/', 
                            pattern = '*.gpkg',
                            full.names = TRUE,
                            recursive = TRUE)


###

counter = 1

for (x in overlay_joined_list) {
  interior_table <- tibble(hex_id = numeric(),
                             country = numeric(),
                             jurisdiction = character(),
                             surface = numeric(),
                             lanes = numeric(),
                             speed_limit = numeric())
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  hex_interior <- read_sf(x) %>% drop_na() %>% st_drop_geometry()
  
  if  (nrow(na.omit(hex_interior)) > 0) {
    hex_interior$surface_type <- replace_na(hex_interior$surface_type, 'Unpaved' )
    hex_interior$surface_type <- case_match(hex_interior$surface_type, 
                                            'Unpaved' ~ '1', 
                                            'Paved' ~ '2')
    hex_interior$surface_type <- as.numeric(hex_interior$surface_type)
    id_list<- as.vector(unique(hex_interior$hex_id))
    for (y in id_list) {
      hex_filtered <- hex_interior %>% filter(hex_id == y)
      int_country <- hex_filtered %>% count(country, sort = TRUE) %>% 
        st_drop_geometry() %>% 
        pluck(1, 1) %>% 
        as.numeric()
      #~ 
      int_jurisdiction <- hex_filtered %>% count(jurisdiction, sort = TRUE) %>% 
        st_drop_geometry() %>% 
        pluck(1, 1) %>% 
        as.character()
      # ~
      int_surface <- max(hex_filtered$surface_type)
      int_lanes <- max(hex_filtered$lanes)
      int_speed_limit <- max(hex_filtered$speed_limit)
    
      scratch_tibble <- tibble(hex_id = numeric(),
                             country = numeric(),
                             jurisdiction = character(),
                             surface = numeric(),
                             lanes = numeric(),
                             speed_limit = numeric())
      # ~
      scratch_tibble <- scratch_tibble %>% 
      add_row(hex_id = as.numeric(y),
             country = int_country,
             jurisdiction = int_jurisdiction,
             surface = int_surface,
             lanes = int_lanes,
             speed_limit = int_speed_limit)
      interior_table <- rbind(interior_table, scratch_tibble) 
      }
    
  } else {
    print('No data: skipping!')
  }
 
  write_csv(interior_table, paste0('outputs/summarized_hexagons/hexagon_chunk_', counter, '.csv'))
  print(paste('Completed:', counter))
  counter = counter + 1
}

hexagon_filtered <- list.files('outputs/summarized_hexagons/', 
                            pattern = '*.csv',
                            full.names = TRUE,
                            recursive = TRUE) %>% 
  as.vector()


for (x in hexagon_filtered) {
  hexagon_interior <- read_csv(x)
  
  if (nrow(na.omit(hexagon_interior)) > 0) {
    print('Success!')
  } else {
    file.remove(x)
  }
}


hexagon_filtered <- list.files('outputs/summarized_hexagons/', 
                            pattern = '*.csv',
                            full.names = TRUE,
                            recursive = TRUE)

final_table <- lapply(hexagon_filtered, read_csv) %>% bind_rows()

overlay_subset_list <- list.files('outputs/overlay_grid_segments/', 
                            pattern = 'hex_group_*',
                            full.names = TRUE,
                            recursive = TRUE)

hexagon_grid <- lapply(overlay_subset_list, read_sf) %>% bind_rows()

hexagon_grid_joined <- left_join(hexagon_grid, final_table, by = 'hex_id')

hexagon_grid_joined <- hexagon_grid_joined %>% drop_na()

write_sf(hexagon_grid_joined, 'outputs/network_components/hexagon_grid.gpkg')

```


